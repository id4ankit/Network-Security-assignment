#include <stdlib.h>#include <stdio.h>#include <pcap.h>#include <netinet/ip.h>#include <netinet/if_ether.h>void got_packet(u_char *args, const struct pcap_pkthdr *header, const u_char *packet){    	static int packet_count = 0; //  Count packets    	//increment packet count    	packet_count++;    	struct ether_header *eth_header = (struct ether_header *)packet;    	uint16_t ether_type = ntohs(eth_header->ether_type);    	if(ether_type != ETHERTYPE_IP) {		printf("Packet %d: Not an IPv4 packet\n", packet_count);		return;	}	struct ip *ip_header = (struct ip *)(packet + sizeof(struct ether_header));	printf("PACKET no. %d: SOURCE IP: %s\n", packet_count, inet_ntoa(ip_header->ip_src));	printf("PACKET no. %d: DESTINATION IP: %s\n", packet_count, inet_ntoa(ip_header->ip_dst));}int main(){    pcap_t *handle;    char errbuf[PCAP_ERRBUF_SIZE];    struct bpf_program fp;    char filter_exp[] = "ip"; // filter expression to capture all IP packets    bpf_u_int32 net, mask;    //open live pcap session on NIC with name enp0s3    handle = pcap_open_live("br-20e3f06a3413", BUFSIZ, 1, 1000, errbuf);    //compile filter_exp into BPF psuedo-code    pcap_compile(handle, &fp, filter_exp, 0, net);    if (pcap_setfilter(handle, &fp) != 0) {        pcap_perror(handle, "Error:");        exit(EXIT_FAILURE);    }    //capture packets    pcap_loop(handle, -1, got_packet, NULL);    pcap_close(handle);   //Close the handle    return 0;}